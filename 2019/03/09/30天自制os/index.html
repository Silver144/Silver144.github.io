<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>30天自制os | Alice Blackbarn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="MathJax.Hub.Config({tex2jax: {inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\\(&apos;,&apos;\\)&apos;]]}});   Day 0了解基本信息 1 . 此书所述的操作系统是用C语言和汇编写成的 2 . 此书的操作环境为Windows 3 . 步骤为，编写源代码-&amp;gt;编译成机器语言-&amp;gt;生成软盘镜像文件-&amp;gt;写入磁盘并作成启动盘 4 . 阶段性计划">
<meta name="keywords" content="OS,作业">
<meta property="og:type" content="article">
<meta property="og:title" content="30天自制os">
<meta property="og:url" content="http://yoursite.com/2019/03/09/30天自制os/index.html">
<meta property="og:site_name" content="Alice Blackbarn">
<meta property="og:description" content="MathJax.Hub.Config({tex2jax: {inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\\(&apos;,&apos;\\)&apos;]]}});   Day 0了解基本信息 1 . 此书所述的操作系统是用C语言和汇编写成的 2 . 此书的操作环境为Windows 3 . 步骤为，编写源代码-&amp;gt;编译成机器语言-&amp;gt;生成软盘镜像文件-&amp;gt;写入磁盘并作成启动盘 4 . 阶段性计划">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-28T06:22:34.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="30天自制os">
<meta name="twitter:description" content="MathJax.Hub.Config({tex2jax: {inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\\(&apos;,&apos;\\)&apos;]]}});   Day 0了解基本信息 1 . 此书所述的操作系统是用C语言和汇编写成的 2 . 此书的操作环境为Windows 3 . 步骤为，编写源代码-&amp;gt;编译成机器语言-&amp;gt;生成软盘镜像文件-&amp;gt;写入磁盘并作成启动盘 4 . 阶段性计划">
  
    <link rel="alternate" href="/atom.xml" title="Alice Blackbarn" type="application/atom+xml">
  
  
    <link rel="icon" href="https://www.sulfur.world/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>
<link rel="stylesheet" href="/css/styles/xcode.css">

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://wiki.arcaea.cn/images/9/9e/Songs_Sulfur.jpg">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>9</strong><br>文章</div></a>
      <a href="/categories"><div><strong>6</strong><br>分类</div></a>
      <a href="/tags"><div><strong>13</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-30天自制os" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/09/30天自制os/" class="article-date">
  <time class="post-time" datetime="2019-03-09T02:19:07.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      30天自制os
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2019/03/09/30天自制os/" class="leancloud_visitors" data-flag-title="30天自制os">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a><strong>Day 0</strong></h3><p>了解基本信息</p>
<p>1 . 此书所述的操作系统是用C语言和汇编写成的</p>
<p>2 . 此书的操作环境为Windows</p>
<p>3 . 步骤为，编写源代码-&gt;编译成机器语言-&gt;生成软盘镜像文件-&gt;写入磁盘并作成启动盘</p>
<p>4 . 阶段性计划，分四周进行总结</p>
<p>ps : 背后有什么奇妙深刻原因让老师选用这本书做实践工作，我暂且蒙在启动区的软盘里面</p>
<a id="more"></a>
<hr>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a><strong>Day 1</strong></h3><p>由于版本0的.img文件可以为版本1或版本2的.nas文件编译得到，故现将光盘里提供的版本2的汇编程序helloos.nas使用nask.exe编译成helloos.img，并重命名为fdimage0.bin并放入含qemu.exe的文件夹，并调用对应文件夹中的Makefile(启动qemu-win.bat)从而得到结果</p>
<p>需要注意的地方：</p>
<p>1 . \\$代表当前行被汇编后的地址，在部分参考书中还会有\\$\\$，这个符号代表当前节被汇编后的地址</p>
<p>2 . 0x55，0xAA为前512字节的最后两个字节，以0x55，0xAA结尾代表此扇区的开头为一个启动程序</p>
<hr>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a><strong>Day 2</strong></h3><p>与第一天一样，制作出来的东西作用完全相同，不同的是Day2用8086汇编指令制作启动区，剩下的工作交给磁盘映像管理工具，并在helloos5中将脚本整合成了Makefile文件</p>
<p>需要注意的地方：</p>
<p>1 . org 0x7c00. BIOS发现引导扇区后，会将这些内容装载到内存0x7c00处</p>
<p>2 . int 0x10 为调用中断服务程序，根据ah的不同会有不同的服务，在此程序中ah = 0x0e 为显示字符，al为字符的ascii码，bl为前景色</p>
<p>使用Makefile可以大大提高工作效率</p>
<hr>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a><strong>Day 3</strong></h3><p>1 . 开始版本(a~d)的作用是读取磁盘中的内容到内存特定位置，首先测试一下，如果屏幕上没出现错误信息那么就成功了，符合预期</p>
<p>(1) . 调用 int 0x13，ah = 0x02作用为读取磁盘内容，al为扇区数，ch为柱面号，cl为扇区号，dh为磁头号，dl为驱动器号，es:bx为缓冲区地址，实际地址为es <script type="math/tex">\times</script> 0x10 + bx</p>
<p>(2) . 考虑到从磁盘数据读取可能会出现问题，因此示例程序增加了retry部分，并设置retry次数上限</p>
<p>2 . 中间的版本(e~g)将引导区代码和操作系统代码分开，并用工具写入同一个磁盘，对g进行测试，qemu界面为全黑，符合预期</p>
<p>(1) . 在haribote.img中，操作系统文件名存储在0x2600处，主体部分存储在0x4200处，在(e)中，主体只有三个字节</p>
<p>(2) . 由于磁盘内容被转移至以0x8000为头的内存区域，故操作系统主体在内存中的位置为0xc200，在代码开头要加上org 0xc200，并在ipl.nas的next代码段最后加上jmp 0xc200</p>
<p>(3) . 为了能够有显示，需要调用int 0x10，令ah = 0x00即为设定显示模式，al为想要设定的模式，此处设定al = 0x13，因此，如果确实执行了我们的操作系统的代码，画面将会变为全黑</p>
<p>3 . 接下来的版本(h~j)进入32位模式并导入c语言</p>
<p>(1) . 记录BOOT_INFO，包括画面模式(示例代码为320x200x8bit)，VRAM地址等</p>
<p>(2) . 将haribote.nas改为asmhead.nas，加入新的代码来切换32位模式并调用c程序</p>
<p>(3) . 示例程序为bootpack.c，先编译成.gas文件，然后转化为.nas文件，再制作成.obj文件，生成.bim二进制映像文件，最后处理为.hrb二进制文件</p>
<p>(4) . 由Makefile可知，作者将asmhead.nas编译为asmhead.bin并与bootpack.hrb做成haribote.sys，导入ipl10.bin所在的.img文件中</p>
<p>(5) . 在(j)中为了实现HLT，使用naskfunc.nas汇编代码设置全局函数，并在.c文件中调用</p>
<p>测试，若黑屏则基本正确，结果符合预期</p>
<hr>
<h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a><strong>Day 4</strong></h3><p>今天的内容是用c语言将数据写入显存区域(0xa0000~0xaffff)，从而在屏幕上显示图案</p>
<p>在harib01a中，函数由汇编编写，参数存放在栈中，让c程序进行调用，显示的效果为纯白屏</p>
<p>harib01b与harib01a差别不大，使用&amp;运算符将图案与地址产生关联从而让图案条形化</p>
<p>harib01c则不需要用汇编，直接使用指针将数据写入显存，d，e均为指针的应用</p>
<p>harib01f为颜色的设定</p>
<p>(1) . 作者使用字符数组，设置每三个相邻的字符为一个颜色的R，G，B，先使用io_out()将调色板号写入0x03c8，然后按R，G，B的顺序写入0x03c9，重复16次，调色板设置完毕</p>
<p>(2) . 进行端口写入时，要关闭中断，可由cli实现，结束后应使用sti恢复中断位，本书中因为中断位存储在EFLAGS寄存器中，可提前将EFLAGS使用pushfd入栈，操作完后使用popfd出栈</p>
<p>harib01g与harib01h是在harib01f的基础上的实践，使用调好的颜色绘制了矩形，我在这里稍微修改了一下代码，画了一个三角形</p>
<h3 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a><strong>Day 5</strong></h3><p>为了使用方便与灵活，将画面信息使用指针存储到变量中，然后将相关信息组织成结构体，易于调用</p>
<p>a，b，c均是在介绍结构体，从d开始回到显示上去</p>
<p>d中显示字符使用8<script type="math/tex">\times</script>16的长方形像素点阵来表示一个字符，使用位运算的方法将字符写入显存</p>
<p>e中增加了字符，使用makefont.exe将字符文件编译成二进制文件，处理之后再链接，就可以通过hankaku + ch <script type="math/tex">\times</script> 16来索引相关的字符了，f则在e的基础上实现了显示字符串的功能，g则使用sprintf函数将变量的值化为字符串从而显示到屏幕上，h在内存中存储了一个大小为16<script type="math/tex">\times</script>16的鼠标指针(透明的地方填充背景色)</p>
<p>i中进行了GDT的初始化(其实在进入32位的时候就已经使用GDT了)</p>
<p>1 . GDT全称Global Descriptor Table，作用是存放段的描述符，其入口由LGDT指令加载到GDTR，LDT就是Local Descriptor Table</p>
<p>2 . 段描述符包括段长，段界限，段属性</p>
<p>首先初始了8192个段，程序中界定了两个段，第一个大小为0xffffffff，基地址为0x00000000，属性为0x4092，第二个大小为0x0007ffff，基地址为0x00280000，属性为0x409a，使用LGDT命令将GDT加载到0x00270000</p>
<p>IDT为中断描述符表，CPU在执行中断程序时，会在IDT中查找对应的中断服务程序，详细内容作者准备第二天再讲</p>
<h3 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a><strong>Day 6</strong></h3><p>开始的工作是分割了源文件，组织头文件，以及整理了Makefile文件，使得结构更加清晰易懂，编译速度也更快，接下来对Day 5的GDT的知识做了相关补充</p>
<p>1 . GDTR为48位，高32位存放GDT基址，低16位存放GDT限长(为GDT字节数-1)，IDTR类似</p>
<p>2 . 在段描述符中，存在把段基址和段大小分成若干部分的现象，这是为了与之前的80286时代的程序兼容</p>
<p>3 . 实际上段界限最多只有20位，表面上有3个字节，实际上有4bit为段属性，这样的话，段的大小最大为1M，但是如果把单位解释称页，就可以达到4G</p>
<p>4 . 设置段属性的作用是防止非特权级程序访问系统专用段，从而危害操作系统</p>
<p>接下来是中断的一些重要知识</p>
<p>1 . PIC分为主从PCI，从PIC连接到主PIC的IRQ2上</p>
<p>2 . PIC内部有中断屏蔽寄存器，8位对应8路IRQ信号，用于忽视中断请求，还有初始化控制数据ICW，ICW1、ICW4用于设置电气参数，ICW3设置为00000100是因为IRQ2用于驱动从PIC，ICW2决定用哪一个管脚通知CPU</p>
<p>3 . int 0x00~0x1f不能用于IRQ，故用int 0x20~0x2f接收IRQ0~15，键盘是IRQ1，鼠标是IRQ12，而对于部分计算机PIC初始化时会产生IRQ7中断</p>
<p>4 . 在调用inthandler21时，需要保护现场(相关寄存器压栈)，执行完返回前要恢复现场(寄存器出栈)，然后执行IRETD</p>
<p>5 . 使用中断处理函数前，需要在IDT中进行注册，这样，CPU在发生中断时，就会自动调用相关处理函数，我在这里修改了一下函数，如果发生键盘中断，则显示keyboard interruption!</p>
<p>测试成功</p>
<h3 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a><strong>Day 7</strong></h3><p>接着上一天的工作，在处理键盘中断的同时获得按键的编码，在此之前，在inthandler21函数中添加一句io_out8(PIC_OCW2, 0x61); 使得PIC能够继续监视IRQ1中断，读取0x60端口的数据，即为大小为8bit的按键编码</p>
<p>为了减少中断服务程序的大小，暂时设立了一个大小为1个字节的缓冲区，并修改HariMain函数使得产生键盘中断时能够CPU能够被唤醒并打印数据，平常情况则休眠，但是如果中断的频率过多则会遗漏，因此要制作FIFO缓冲区</p>
<p>1 . 根据先来先处理的原则，此缓冲区为FIFO缓冲区</p>
<p>2 . 缓冲区整合为结构体更加灵活，不仅可以任意取地址，而且可以设置标记来标注其状态</p>
<p>为了能够接收鼠标中断，要先令鼠标控制电路有效，再令鼠标有效，实际上如果键盘控制电路有效则鼠标电路就有效，然而键盘控制电路并没有CPU快，故许需要等到键盘控制电路可以处理信息时CPU再发送指令，设置为鼠标模式，然后激活鼠标，此时，鼠标会产生一个中断，此处修改了一下代码，若鼠标产生中断，则显示mouse interruption!</p>
<p>测试成功</p>
<p>接下来是获得从鼠标发送来鼠标的数据，根据代码可以看出，除了分别通知PIC1、PIC0，IRQ12、IRQ2的受理已经完成，其他的几乎一样，且读数据的端口也是0x60端口，有缓冲区的帮助，获得并使用鼠标数据的方法也简单了，但是我们使用鼠标是为了让它动起来，于是需要把数据进行适当的转换，这就是下一天的工作了</p>
<h3 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a><strong>Day 8</strong></h3><p>这一天的首要工作是解读鼠标的信息，并让鼠标在屏幕上移动</p>
<p>1 . 鼠标发送3个字节的信息为1组，一开始的工作是将3个字节的信息分别放入一个特定的数组，完成后一起显示到屏幕上，其中关于鼠标数据的信息可以整合成结构体</p>
<p>2 . 在MOUSE_DEC结构体中，unsigned char buf[3]存储鼠标发送的3个字节，phase为其存到第n个字节的状态标识，x为buf[1]的内容，y为buf[2]的内容，根据测试，x、y的含义分别是一段时间内鼠标横纵坐标的<strong>相对变化量</strong>，鼠标的btn为buf[0]的第0~2位，<strong>0~2位为1分别代表操作了左键、右键、滚轮</strong>，根据buf[0]第4位、第5位的值分别对x、y做出修正(实则为将16位负数变为64位负数)，通过初始坐标我们就能计算鼠标的实时坐标</p>
<p>3 . 在绘制鼠标的时候，注意鼠标不能越界，同时，绘制新的鼠标和坐标前，要先将原来的数据和鼠标用背景色填充，这样，鼠标就可以绘制出来，而且其坐标也能一清二楚，不过需要注意其坐标原点位于左上顶点</p>
<p>接下来要讨论进入32位模式前的一些工作</p>
<p>在看的另一本参考书中，进入保护模式的主要步骤有以下几个</p>
<p>1 . 准备GDT</p>
<p>2 . 用LGDT加载GDTR</p>
<p>3 . 打开A20地址线</p>
<p>4 . 置cr0的PE位</p>
<p>5 . 跳转，进入保护模式</p>
<p>在这本书中，首先禁止了中断，防止干扰，然后打开了A20地址线，使CPU获得1M以上的寻址能力，接下来加载了临时的GDT，并设置cr0寄存器，设置PG位为0从而禁止分页，PE位为1从而切换到保护模式，然后将所有的段寄存器(除了CS)设置为0x08</p>
<p>接下来的代码将bootpack开始的地址开始的512KB的内容复制到0x280000的位置，将0x7c00处的启动扇区复制到0x100000的位置，将0x8200处的磁盘内容复制到0x100200处，这样做是作者设计了内存分布的情况，0x100000~0x267ffff用于保存软盘的内容</p>
<p>后面的代码就是先对bootpack.hrb中部分内容进行传送，等到没有要传送的数据的时候，从0x28001b执行bootpack.hrb</p>
<p>接下来的作用就是将0x60端口的冗余数据清理出来，紧接着是memcpy程序，单位为4字节，asmhead.nas的最后则是定义GDT0和GDTR0，并对齐至16字节，通过代码看出，GDT0规定的<strong>可读写段从0x00000000开始，界限为0xfffff，可执行段从0x00280000开始，界限为0x7ffff</strong></p>
<p>最后在HariMain()中创建GDT和IDT后，初始化PIC，打开中断并进行相关设备的初始化就可以处理中断了，至此，工作已经结束，其中部分问题会在以后解释</p>
<h3 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a><strong>Day 9</strong></h3><p>今天的第一个任务是进行内存容量检查</p>
<p>1 . 测试cpu是否为486及以上，若是，则关闭高速缓存</p>
<p>2 . 开始测试内存，一开始向内存中写入一个值，然后反转，测试是否相等，若相等，则再次反转测试是否相等，若仍相等，则此内存有效</p>
<p>3 . 测试时注意编译器的优化问题导致程序失效</p>
<p>第二个任务是管理内存，以128M的内存为例</p>
<p>1 . 比较简单的方法是将128MB的内存划分为32768个4KB大小的区域，然后设置一个大小为32768的数组，来标记哪些块目前为可用。</p>
<p>2 . 也可以使用结构体列表的思路，将空闲地址基址与大小写入结构体数组，然后需要时数组轮询即可得到需要的资源，这样占用的内存也少</p>
<p>3 . 在使用结构体的策略时，可以将零散的小空闲内存合并为大的整块空闲内存，这样既节省空间，也减少程序轮询的次数</p>
<p>4 . 归还内存时首先测试是否能与前一块的内存区域合并成一块更大的空闲内存，若可以则合并，然后测试能否与后一块内存区域合并，若可以则合并，若均不可以，则加一块描述符用于描述新释放的内存</p>
<p>若只在HariMain()函数分配0x00001000~0x0009e000与0x00400000~0x00500000，则可用内存加起来仅有5752KB</p>
<h3 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a><strong>Day 10</strong></h3><p>今天首先继续进行内存管理</p>
<p>1 . 把内存分配和释放的最小单位为4KB，这样有助于管理，而且不会产生大量的不连续的小内存段</p>
<p>2 . i = (i + 0xfff) \&amp; 0xffffff000 的意思与 x = ((x + 99) / 100) $\times$100的意思差不多，前者是为了将第四位向上取整，后者是百位向上取整</p>
<p>接下来是实现叠加窗口，这个需要不断地重新绘制才能达到目的</p>
<p>1 . 首先创建一个图层结构体，用于存储每一个图层的信息(坐标、大小、每一个像素的值、高度等，我理解的高度为图层的优先显示程度)</p>
<p>2 . 若要切换窗口，只需要修改某个图层的高度，然后调整其他图层的高度</p>
<p>3 . 在刷新函数中，使用的策略为从图层0到图层top，逐个在vram里面写入，达到覆盖的效果，但是由于写入的次数过多，故会产生卡顿</p>
<p>4 . 里面的背景色号为判断图层的这一处是否应该覆盖，若为背景色，则此处保留上一个图层的颜色，而颜色编号为0~15，故背景色设为99</p>
<p>5 . 每产生一次鼠标中断，屏幕会刷新一次，这样，鼠标就能运动起来</p>
<p>由于之前的函数写入次数过多，故接下来进行一些改进</p>
<p>1 . 仅仅设置移动区域进行重写，其他区域保持不动，这样工作量确实少了一些，但是并不明显</p>
<p>2 . 虽然其他区域保持不动，但是还是要进行大量的if判断，浪费了时间，因此，需要改动循环的范围，原来在其图层上每个点都遍历，现在仅在移动的区域进行遍历，减少了循环的次数，从而也大大降低了工作量，比之前的更加流畅</p>
<p>至此，图层覆盖的问题也能够解决了</p>
<h3 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a><strong>Day 11</strong></h3><p>今天的首要事情是支持鼠标能够真正实现全屏幕覆盖，这个问题比较简单，进行如下修改:</p>
<p>a. 仅满足左上角的点可以位于频幕</p>
<p>b .仅仅刷新鼠标矩形与整个窗口重叠的地方</p>
<p>这样鼠标就可以实现全屏幕覆盖而且在窗口外可以隐藏一部分了</p>
<p>接下来就是做窗口了，大体思路是要先初始化一个图层，并绘制上相应的东西，做了如下操作：</p>
<p>1 . 绘制关闭按钮，与鼠标的绘制有相似之处</p>
<p>2 . 创建窗口图层并设置相应的缓冲区，申请内存</p>
<p>3 . 在窗口的缓冲区(buf_win)中写入字符</p>
<p>4 . 调整窗口出现的位置并设置优先级(鼠标最上，vram最下)，然后显示</p>
<p>成功显示</p>
<p>接下来是进行的一个小应用，令计数器无限计数并使用窗口显示，这个只需要修改循环中的代码就可以了，这里我将sprintf中的参数counter改为counter / 1000，可见的速率减慢为原来的1 / 1000</p>
<p>很明显这里有闪烁的迹象，原因是每次循环都是先刷新整个界面，然后是窗口，最后是鼠标，在刷新整个界面的时候就会看到相应的地方在闪烁(仅数字地方刷新是因为上一天的优化策略)，于是，将刷新函数修改为仅让想刷新的图层及以上刷新</p>
<p>闪烁现象消失了(截图看不出任何现象)</p>
<p>但是还是会有一个问题：鼠标的优先级比窗口要高，鼠标放在上面的时候依然会闪烁，于是，需要一种新的刷新方法，大体思路如下</p>
<p>1 . 创立buf_map，使得屏幕上每一个像素对应一个标记，这个标记与每一个图层是一一对应的</p>
<p>2 . 于是，从底层图层往高层图层刷新的时候，若某层某处在刷新区内，但是此处在map中的标记为更高级的图层，则并不会将颜色写入内存</p>
<p>这样的话，刷新时鼠标不会闪烁，性能的话，虽然每次刷新前需要刷新map可能会有额外的开销，但是当重叠区域过多时，写内存的开销会极大，此时刷新map可去除这些开销，综合下来性能有所提高</p>
<h3 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a><strong>Day 12</strong></h3><p>今天首先需要给操作系统添加定时器</p>
<p>1 . 这个功能由IRQ0提供，可以通过设定PIT来控制中断产生的频率，通过资料可知，PIT脉冲的频率为1193180Hz，所以若把周期设为11392，中断频率就为100Hz</p>
<p>2 . 通过往0x43端口写入0x34，就可以对中断周期进行调整，先往0x40端口写入周期低8位，再往0x40端口写入周期高8位，对周期的修改就完成了</p>
<p>3 . 然后在主函数中将IMR的0位设置为0，就可以按设置的频率发生时钟中断了</p>
<p>4 . 最后编写中断处理函数，并在IDT中注册，准备工作就全部完成了</p>
<p>定时器可以很方便地管理程序，一段固定时间结束后就会执行某个任务，举例，经过5s后就输出”5 sec”的字样</p>
<p>1 . 首先设置一个结构体，里面含有经过时间，剩余时间，一个缓冲区和数据，当剩余时间归零的时候，数据便会打向缓冲区</p>
<p>2 . 主函数中设置为，若缓冲区有数据，则直接往屏幕打入”5 sec”</p>
<p>测试成功</p>
<p>为了能使用多个超时定时器，需要设置一个超时定时器结构体数组来进行管理，按顺序初始化并分配缓冲区内存后，只需要编写对应定时器超时后的活动，就可以在不同的程序中使用了，比如</p>
<p>3s的定时器超时后显示3s，10s的定时器超时后显示10s，光标定时器每隔0.5s显示一次(多次重置定时器)</p>
<p>接下来对此进行优化</p>
<p>1 . 第一个优化的点是在中断处理函数消除timeout的自减，只与count进行比较，意义也变为超时的时刻</p>
<p>2 . 第二个优化的点在于并不需要时刻监督是否超时，因为只需要设定好下一次超时的时刻就能进行活动，于是设置下一个超时点，不到则不操作缓冲区</p>
<p>3 . 第三个优化的点在于尽快找到超时的定时器，只需要对初始超时时刻进行排序，若有N个超时的定时器，则后面未超时的直接覆盖前面的N个，下一次超时时间就是第0个定时器的超时时间</p>
<h3 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a><strong>Day 13</strong></h3><p>由于目前新开一个定时器就需要新开一个缓冲区，故今天的首要任务是将FIFO缓冲区进行整理，方法是在同一个缓冲区内写入不同的数来确定超时的定时器</p>
<p>ps: 可能会有人认为有相同时刻完成任务的情况下会遗漏信息，但其实不会，因为那个结构体中存储定时器的数组仅当某个定时器完成任务才会移除它，但也有风险，可能会造成逻辑错误</p>
<p>这样性能确实得到了改善，受此启发，其实也可以将鼠标和键盘也归入一个缓冲区，具体策略同上，方案如下</p>
<p>1 . 0~1设为光标闪烁的定时器</p>
<p>2 . 3和10分别用作3s与10s的定时器</p>
<p>3 . 256~511标识键盘输入</p>
<p>4 . 512~767标识鼠标输入</p>
<p>这样，每次在缓冲区中获得一个数，系统能够判断来源，并进行相应的处理</p>
<p>接下来继续对中断处理进行优化，这一次优化的地方在于上一天的移位操作</p>
<p>1 . 在前一天的模型中，当一个定时器超时后，后面的所有运行的定时器向数组前面移动，实际上，我们可以使用链表根据超时时刻来将定时器进行排序，这样的话，就不需要移位</p>
<p>2 . 这样不仅省去了移位的功夫，而且去掉了定时器指针数组，因为所有的定时器用链表串起来，只需要链表头而已</p>
<p>接下来为了进一步减少中断处理函数运行时间以及精简代码，引入哨兵机制，具体的思想如下</p>
<p>哨兵作为永远存在的定时器，其绝对不会出链表，在原来的timer_settime函数中，需要判断四种情况，然而由于哨兵的出现，作为第一个定时器插入和插入队列最后一个的情况不会出现，前者变成了插入队首中的一种情况，后者变为插入两个定时器之间的一种情况</p>
<p>其实这个主要是简化了timer_setting的写法，对于中断处理函数优化为少判断一个if语句，变化不大</p>
<h3 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a><strong>Day 14</strong></h3><p>今天开始的任务是提高分辨率，之前的分辨率仅为320$\times$200$\times$8bit，现在可以提高到640$\times$400$\times$8bit甚至1024$\times$768$\times$8bit</p>
<p>1 . 必须使用VBE才能切换到这些画面模式，首先需要确定机体是否含有VBE，给es赋值0x9000，di赋值0(es和di的作用是提供缓冲区)，ax赋值0x4f00，再执行int 0x10中断，若机体含VBE，则ax的值会变为0x004f</p>
<p>2 . 需要确定VBE版本，若不是2.0以上，则不能使用高分辨率，将地址为[es:di + 4]的16位数与0x0200进行比较，若小于，则只能使用320$\times$200$\times$8bit</p>
<p>3 . 查看需要的画面模式是否可用，首先将此画面模式对应的号码写入cx，将ax置为0x4f01，然后执行int 0x10，若ax为0x004f，则可用</p>
<p>4 . 确认颜色数是否为8，是否为调色板模式，画面模式号码可否加上0x4000，这些均可以与写入缓冲区的数进行比对，全部符合就可以设置了</p>
<p>5 . 切换到VBE画面模式时，需要设置ax寄存器为0x4f02，bx寄存器为画面模式对应的号码，实际上，要将画面模式号码加上0x4000才能顺利运行</p>
<p>之前在处理键盘中断的时候，屏幕上仅仅只是显示了接收的键值，不过进行一些处理后就可以将其转化为对应的字母</p>
<p>1 . 根据键值对应字符的关系，设置一个字符表，一一对应键值与字符，不可见字符或保留键值设置为0</p>
<p>2 . 函数体中，只需要以键值为索引，然后选择字符并打印出来即可</p>
<p>3 . 要想达到持续输入和退格的效果，只需要在显示输入字符后，将光标的横坐标加一个字符的距离，在按退格时，只需覆盖之前的光标图案，删除的文字自动会被光标覆盖</p>
<p>接下来是实现鼠标拖动窗口，实际上这并不完善，因为他实现的方式是只要鼠标一点，窗口就会移动到相对于鼠标固定的一个位置，对于这个，我的解决方案如下</p>
<p>1 . 直接使用第11天为了消除闪烁所引进的map，查看鼠标顶点向上一个像素的坐标对应的图层号，若图层为桌面则跳过，若为窗口则拖动对应的图层</p>
<p>2 . 现阶段考虑到效率，拖动时可以将直接图层移动到相对鼠标固定的一个位置</p>
<h3 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a><strong>Day 15</strong></h3><p>多任务：执行多个任务的时候，CPU在很短的时间内进行任务切换，由于一般切换时间较短，所以看起来就像多个任务同时在运行</p>
<p>为了实现这种任务切换，在切换时，系统要保存这个任务的一些信息，包括各特权级堆栈段、寄存器状态等，在载入下一个任务前，需要将下一个任务的信息还原，这样才能保证不会出现相关错误，因此，需要一个结构体(TSS)来存储这些信息</p>
<p>TSS包括寄存器保存区域、内层堆栈指针区域、地址映射寄存器区域、链接字段以及其他字段，TSS是内存段的一种，需要在GDT中定义后再使用，在这里，暂时先将ldtr置为0(系统中并未设置LDT)，iomap置为0x40000000，接下来进行一次两个任务间的切换</p>
<p>1 . 创建两个TSS，ldtr置0，iomap置0x40000000，在GDT里注册</p>
<p>2 . TR是任务寄存器，若一个任务要占用CPU，其TSS在GDT中的号码乘以3的值要写入TR，在汇编代码中设置好相关函数</p>
<p>3 . 首先是任务a切换至任务b，先准备好任务b的TSS，设置eip为task_b_main字段开头，esp为task_b_esp(需要手动新开辟一块内存)，并设置其他有关寄存器(EFLAG中要设置为可中断)</p>
<p>4 . 本次设置为10s计时器超时后就进行任务切换(直接在任务a的代码中写入切换进任务b的函数，之后有专门的程序进行管理)，hlt()不太明显，写上相关的文字可能会更加直观</p>
<p>测试成功</p>
<p>接下来在任务b中加入5s后切换回任务a的代码，与HariMain()函数中的代码相似，注册一个超时时间为5s的定时器，不断使用时钟中断唤醒CPU并查询是否超时，若是，则返回任务a，进一步，缩短切换的时长，并让task_b能够直观显示运行时长</p>
<p>为了实现更多任务的相互切换，首先需要精简task_switch()函数，使得任务号能通过参数传递，在这里有一个要点，对于一个任务的栈来说，esp指向其栈顶，在作者的代码中，将[esp+4]的值设为sht_back，那么esp的值需要为申请内存的上界减8，具体可以看下面的图</p>
<p>接下来要为多任务设置一个管理的程序，之前的多任务是在一个任务中主动切换到另一个任务，然而理想的多任务则是有一个专门来管理多任务的程序</p>
<p>1 . 主体逻辑为设置定时器，等定时器超时后自动切换任务，因此函数需要设定定时器和切换任务的功能</p>
<p>2 . 在IRQ0的中断处理函数中调用切换任务的函数，每一次时钟中断中查看mt_timer是否超时，若是，则调用任务切换函数</p>
<p>3 . 不能在中途调用任务切换函数，因为这样会导致这一个中断处理函数未结束时将中断标志位设置为1，从而可能引发另一个中断，导致错误</p>
<h3 id="Day-16"><a href="#Day-16" class="headerlink" title="Day 16"></a><strong>Day 16</strong></h3><p>为了让多个任务能够自动化管理，需要创建一个结构体(TASK)进行存储任务的各种信息(包括TSS、状态、编号)，然后将所有的任务结构体结合到一起，并加上调度信息(任务数、当前运行任务的编号)合成一个新的结构体(taskctl)，这样任务的状态就一目了然，调度也更方便，接下来，设置4个函数</p>
<p>1 . task_init()，作用是为taskctl申请内存，并把所有任务的TSS在GDT中注册，然后设置第一个运行的任务，并对定时器进行初始化，设定一个切换任务的时长</p>
<p>2 . task_alloc()，这个函数的作用并不是为TASK申请内存，而是初始化第一个未使用任务的TSS，并把状态设置为正在使用</p>
<p>3 . task_run()，这个函数的作用是将task加到队列末尾，并设置相关信息</p>
<p>4 . task_switch()，作用是设置此任务的时间片，每到时间片过期，IRQ0的中断处理函数就会调用此函数，运行队列中的下一个程序，若只有一个程序则不进行切换，若这个任务是队列的最后一个任务，则下次运行第一个任务</p>
<p>由于系统中有的任务需要更多的时间，有的任务并不需要那么多时间，因此，加入休眠功能，使得工作量少的任务可以将多余的时间给下一个任务，具体操作为首先找到其队列中的位置，让所有在它后面的任务向前移动一个位置，并设置相关信息，若这个任务正在运行，则进行任务切换</p>
<p>ps: 当任务过多的时候这个移位操作会很费时间，应该在TASK结构体中加一个next指针指向下一个任务，这样可以缩短时间</p>
<p>任务唤醒可以有多种形式，比如任务在等待键盘输入，这种情况下可以设置为当fifo缓冲区不为空的时候将任务唤醒，书上在fifo中添加了一个task指针，可以指定一个任务在fifo缓冲区不为空的时候被唤醒，这里可以改成添加一个指针头，当fifo不为空的时候唤醒这个头牵引的任务队列，而且有时候并不是所有的数据都要唤醒任务，若是在等待键盘，则只需要设置缓冲区数据为键盘对应的值时唤醒即可</p>
<p>这里可以测试一下刚刚的多任务程序，设定4个任务分别代表4个窗口，其中三个窗口进行计数，一个供键盘输入，这里的三个任务共用task_b_main()函数进行计数，每隔1s显示一次，任务a设置为fifo缓冲区中有数据就被唤醒</p>
<p>测试成功</p>
<p>接下来设定任务的优先级，实际上，这里的优先级只是时间片长短的差异，标准优先级为默认时间片，这里设置为优先级值越高，时间片越长，在TASK结构体添加此属性，修改task_init()函数和task_switch()函数，使得任务可以根据优先级设置定时器，修改task_run()函数，使得任务可以自由设定优先级，在这里，设定三个定时器的优先级分别为1，2，3进行测试</p>
<p>实际运行情况接近理论值</p>
<p>接下来引进优先级的另一个机制，创建不同优先级的队列，将所有任务分配到不同优先级的队列，当且仅当高优先级队列无任何任务时，低优先级队列中的任务才可以运行，因此，需要引入一些结构体和表示量，而且逻辑也要进行相应的改变</p>
<p>1 . 将任务添加到任务队列的时候，需要设定level，若一个任务本来就是活跃的，则先需要将其从原来的level队列中删除，重新添加到任务队列尾部，然后设定level再将其添加到对应的level队列中</p>
<p>2 . 任务切换时，首先要根据level[i].running属性找到最高优先级队列，然后按队列中任务的顺序进行切换</p>
<p>此时，创建任务或添加任务的时候加上level参数，就可以只运行最高优先级队列中的任务了，但是这里的问题十分明显，当高优先级队列中的任务不会自我休眠或高优先级队列持续有任务输入，低优先级的所有任务都会被饿死</p>
<h3 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a><strong>Day 17</strong></h3><p>多任务管理函数需要预测到系统无任何任务的情形，但是区分这种情形较为麻烦，因此，采用哨兵的机制，在任务队列的最后预留一个永远存在的哨兵任务，就可以免去这种工作</p>
<p>接下来就要创建命令行窗口了，目前预计的功能有显示窗口和光标以及打出字来，需要以下步骤</p>
<p>1 . 分配一个适当高度的图层，并制作窗口ui</p>
<p>2 . 新建一个函数用于接收缓冲区的数据，并进行判断(如0和1为光标定时器超时的标志)，与HariMain()中的代码相似</p>
<p>3 . 进行任务注册，并设定level和优先级</p>
<p>由于task_a的优先级为1，task_con的优先级为2，故此时不可能有文字能够输入到命令行窗口上，因此需要进行设定，能够通过某种方式(如win可以用鼠标来选择窗口)来使文字输入到想要的窗口</p>
<p>1 . 设定按下某个键可以进行窗口切换，如Tab(也可以自行设定为其他的)，找到Tab的键值(0x0f)，当缓冲区的数据为0x10f时，就进行切换(如设置flag，把flag设为不同的值就代表不同的窗口)</p>
<p>2 . 设置变量flag，flag为0时表示此时字符将输入给task_a，按下tab会将flag修改为1，字符会输入给task_con的缓冲区，从而激活task_con，下一次时钟中断时，task_a的缓冲区无数据，故从任务队列中离开，task_con就能处理缓冲区数据</p>
<p>3 . 为了处理退格键，task_con()要判断缓冲区的值，若为可见字符，则打印出来，若为退格键的键值，则回退一位，并相应地设置光标的坐标</p>
<p>但是很明显这样并不能处理shift按出的符号，因此需要采取以下策略</p>
<p>1 . 设置一个标志位flag，flag为0表示此时没有按下shift，不为0则代表按下了shift，并设置另一个键值与字符的对应表以查找同时按下shift和另外一个键的时候会得到的符号</p>
<p>2 . 按键按下和松开的键值是成对出现的，因此可以直接从缓冲区判断shift是按下还是松开并设置相关flag</p>
<p>目前输入的字母只能显示大写，这是因为未对Shift和CapsLock进行判断，当且仅当CapsLock和Shift同时选中或同时不选中时，输入的字母为小写，而CapsLock的状态可以从binfo-&gt;leds的第6位得知，因此可以判断key_shift和binfo-&gt;leds的第6位是否同为0或同为1，若是，把缓冲区的键值加上0x20，大写字母的键值加上0x20就为小写字母的键值，然后显示到屏幕上</p>
<p>那么有没有办法设置指示灯呢，当然可以，只要向键盘控制器发送对应的数据就可以进行设置</p>
<p>1 . 准备好要发送的数据，先发送0xed，再发送0x??，??的第0位代表ScrollLock，第1位代表NumLock，第2位代表CapsLock(置1为打开)，其余位设置为0</p>
<p>2 . 往0x60端口依次发送数据，每发送一次数据若返回0xfa，则代表发送成功，可以发送下一个数据，若返回0xfe，则需要等待键盘控制器准备好后，再发送一次未发送成功的数据</p>
<p>两次发送成功后就可以设置对应的Lock灯打开或关闭了</p>
<h3 id="Day-18"><a href="#Day-18" class="headerlink" title="Day 18"></a><strong>Day 18</strong></h3><p>今天的第一个任务是控制光标只在被选中的窗口进行闪烁</p>
<p>1 . 在所有关于光标的活动中设置一个flag，当flag大于0时光标的活动(如着色、缓冲区刷新)才能够进行，否则不能进行，flag的值由tab键决定</p>
<p>2 . 若是由一个任务窗口切换到另一个任务窗口，则可以在切换的时候向其缓冲区传递信号，这里，实现的是2为激活光标，3为关闭光标，故可以在另一个任务函数设置若缓冲区接收到2，则flag设为相应的数据，为3则为-1</p>
<p>接下来要让命令行接收回车，秉性先做样子再做功能的原则，先实现按回车能够让光标往下移一行，与光标在最后一行时让最上面一行消失的效果</p>
<p>1 . 在console_task函数中加入cursor_y变量，设置为缓冲区收到数据266(回车的键值是10)之后cursor_y加1并输出提示符，之后刷新光标就会在下一行显示 </p>
<p>2 . 当光标在最后一行时，cursor_y设置为不变，并且把缓冲区的所有字符向上移一行(即将(x, y)的值设置为(x, y+16)的值)，最后一行用空格代替，刷新屏幕后即可看到效果</p>
<p>然后开始编写这个命令行的第一个命令mem，作用是显示所有内存和可用内存</p>
<p>1 . 设置字符数组cmdline，作用是存储在此行输入的字符串，每输入一个通常意义的可见字符，cmdline就会接收这个字符减256的值，按下回车时进行判断</p>
<p>2 . 按下回车时，若cmd为空，则为执行换行操作，若为”mem”，则在屏幕中打印出总内存和可用内存的值，这个值在<strong>day 9</strong>中的操作可以得到，若为其他字符串，则输出”Bad Command”</p>
<p>3 . 内存的值是在Harimain中得到的，因此事先要为task_console开辟一块内存作为栈，并将内存的值压入栈中</p>
<p>cls命令十分简单，仅仅在判断cmdline中的值正确之后将显示窗口部分的缓冲区填满空格对应的数就行了</p>
<p>最后是dir命令，通常这个命令可以输出当前目录的文件信息，由于目前本操作系统并没有文件系统，因此仅仅输出磁盘映像中的文件</p>
<p>1 . 在进入32位模式之前，操作系统已经将磁盘信息写入内存，存放文件信息的开始地址在映像中是0x2600，在内存中就是0x102600</p>
<p>2 . 每个文件的信息有固定的形式，我们可以设置结构体来存放，0~7字节为文件名，如果第一个字节为0xe5就代表文件已删除，8~10字节为文件扩展名，第11字节为属性信息，12~21字节为保留字节，22~25字节为时间戳，26~27字节表示的是此文件在磁盘上存储的扇区号，28~31字节为文件大小</p>
<p>3 . 要实现这个命令，只需判断cmdline的值，若是，则用字符串格式化存放文件名、扩展名与大小，然后显示到屏幕即可</p>
<p>我在这里改了一下Makefile，把自己的一个文件a.txt复制到磁盘了，最终也得到了正确的显示</p>
<h3 id="Day-19"><a href="#Day-19" class="headerlink" title="Day 19"></a><strong>Day 19</strong></h3><p>今天的第一个任务是编写type命令，效果相当于cat命令，命令格式为type x.x </p>
<p>1 . 首先需要找到文件x.x在内存中的位置，这个可以从文件信息的clustno得出，计算公式为 实际地址 = 0​x​103e00 + clustno$\times$0x200</p>
<p>2 . 判断逻辑为，先获取文件名并全部转化为大写，然后在0x2600开头的内存中寻找符合文件名的文件信息，若找到则读取clustno，并根据公式来计算存储地址，然后读出其大小，最后逐个字符打印即可，若没找到，则输出”File not found”，由于0x4200就是haribote.sys存储的位置，因此最多只有224个文件信息</p>
<p>3 . 由于不支持制表符、换行符和回车符，因此需要进行设置，为了让Windows与Linux的文件都能正确显示，回车符设置为什么也不做，制表符设置为最大长度四个字节，让光标与最近的四字节对齐，换行就重置cursor_x，cursor_y加1</p>
<p>但是上述type命令能正确显示的前提是文件大小不能超过512字节，因此需要添加对FAT的支持</p>
<p>1 . 如果遇到的文件大小大于512字节，则会将剩下的部分存在另外的扇区，而这个扇区的号码信息存放于0x100200~0x1013ff的区域，名为文件分配表(FAT)</p>
<p>2 . FAT的数据被进行了压缩，以3个字节代替2个数，12 34 56会被解码成412 563，FAT的第N个数据为FF8~FFF的数则代表文件数据结束，否则代表此文件的数据没有结束，值则为接下来的数据存放的clustno，比如FAT的第1个数据为2，则clustno为1的文件没有结束，接下来512个字节的数据会存放到2号扇区所在的区域</p>
<p>3 . 对于新的type命令，先对FAT进行解压缩，然后申请一块新的内存用于存放文件，然后不断判断大小，若小于512，则写入后直接返回，若大于512，写入512字节后得到新的clustno并把大小减512，直至大小小于512</p>
<p>由于书上没有测试，因此我自己往软盘写入了一个大小684字节的文件并执行type</p>
<p>很明显，它正确打印出了最后的字符，其实前面的也打印了，不过换行的速度太快</p>
<p>接下来就要实现编写应用程序了，执行程序的过程是，首先将程序内容读取至内存，然后在GDT中进行注册，最后进行farjmp</p>
<p>1 . 编写一个程序命名为HLT，后缀为HRB，最简单的效果就是hlt并不断循环，这样会整个死机，效果明显</p>
<p>2 . 在命令行窗口的程序中添加对字段”hlt”的支持，使得输入hlt后将HLT.HRB读入分配的内存，在GDT中注册，最后进行farjmp，若文件丢失，输出”File not found”</p>
<p>3 . 由于GDT的1~1002号已被注册，故只能注册1002以后的号</p>
<h3 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a><strong>Day 20</strong></h3><p>API为应用程序接口，是一些预先定义的函数，在操作系统中一般都会有API，今天首先实现能够显示字符的API</p>
<p>1 . 使用一个测试程序，设置为将自定的字符移入al后调用_asm_cons_putchar()来将其打印至屏幕上，_asm_cons_putchar()的作用是先将待打印的值和console结构体地址压入栈再调用_cons_putchar()</p>
<p>2 . _asm_cons_putchar()所在的位置hlt.hrb是不知道的，所以需要在操作系统make过后再在bootpack.map中手动查询其地址并写进hlt.nas</p>
<p>3 . 由于系统的段在GDT注册为2号，hlt.hrb所在的段号为1003，因此，hlt.hrb中需要使用far-call，相应的在_asm_cons_putchar()结尾需要使用retf来返回</p>
<p>一般来说，在应用程序执行结束后，用户能够操作控制台执行下一个程序，这里设置为无限hlt，在之前的代码中，并不打算返回，因此使用了farjmp，可以改成使用farcall，然后在程序中使用retf返回</p>
<p>由于_asm_cons_putchar()的地址在每次编译的时候可能会变化，需要修改hlt.hrb的指令，这十分浪费时间，而且调用操作系统的函数时，地址也不应该需要应用程序担心，因此，采用中断处理时使用的策略来解决</p>
<p>1 . IRQ只有15个，CPU通知异常的中断有32个，然而IDT可以设置256个函数，所以，可以将_asm_cons_putchar()注册在IDT中，号码可以是0x30~0xff任意，设为0x50，hlt.hrb只需要把字符存在al中，使用int 0x50指令就可以打印出字符了</p>
<p>2 . 由于_asm_cons_putchar()成为了中断处理函数，因此在结尾返回的时候需要使用指令IRETD</p>
<p>对于不同的可执行文件xx.hrb，目前的格局是有多少个可执行文件命令行窗口就要设置多少条指令，这显然很不可取，因此，需要进行自动判断</p>
<p>1 . 总体设计思路为保留一部分原有命令，如cls，mem等，若cmdline中的字符串为某个可执行文件名，则取出并执行，否则输出”Bad command”</p>
<p>2 . 判断的过程为首先判断输入的字符串是否在磁盘中，若不在，加上.hrb再查找一次，这样不管是输入xx还是xx.hrb都能够执行xx.hrb，还是不在就确信没有此文件，若有，分配内存，执行，farcall，回收内存，并返回</p>
<p>在使用寄存器来指示字符所在位置时需要注意，int 0x40中不会自动保存寄存器的数值，故应该手动进行pushad和popad操作</p>
<p>然后实现在cmd窗口打印字符串的API，设置不同方式打印，具体的方式由ah决定，书上设定了三种，但我觉得第一种毫无必要</p>
<p>第2种方式是打印以’’\0’结尾的字符串，作者本来想直接使用ebx存储地址，但是错误在于应用程序被载入内存后会有一个偏移，导致以ebx为地址的字符串并不是我们所希望的字符串，故在调用api后，需要把ebx加上申请到的内存的开始地址作为cons_putchar0()的参数，这样才能正确定位到我们的字符串</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/09/30天自制os/" data-id="ck4zli4ew0000bsluz8xpppg0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作业/">作业</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/14/快速傅里叶变换/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          快速傅里叶变换
        
      </div>
    </a>
  
  
    <a href="/2018/11/27/th12buff原理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">th12buff原理</div>
    </a>
  
</nav>

  
</article>




</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Alice Blackbarn</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://wiki.arcaea.cn/images/9/9e/Songs_Sulfur.jpg">
    <h2 class="author"></h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>9</strong><br>文章</div></a>
      <a href="/categories"><div><strong>6</strong><br>分类</div></a>
      <a href="/tags"><div><strong>13</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://score.royalflare.net" target="_blank" title="皇家烈焰">
          皇家烈焰
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/xfgryujk" target="_blank" title="xfgryujk">
          xfgryujk
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <h1>revive</h1>
    </div>
    
  </div>
</footer>

    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>




  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.article-title').length > 1) {
        showTime(Counter);
      }
    });
  </script>




<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>